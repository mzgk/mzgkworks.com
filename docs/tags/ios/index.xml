<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ios on mzgkworks.com</title>
    <link>http://mzgkworks.com/tags/ios/index.xml</link>
    <description>Recent content in Ios on mzgkworks.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <atom:link href="http://mzgkworks.com/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>iOSでの画面遷移（Segue/Modalの方針・データ授受・ライフサイクル）の確認</title>
      <link>http://mzgkworks.com/post/iso-transition-segue-modal/</link>
      <pubDate>Tue, 22 Nov 2016 18:19:42 +0900</pubDate>
      
      <guid>http://mzgkworks.com/post/iso-transition-segue-modal/</guid>
      <description>

&lt;p&gt;Single ViewController間の画面遷移に関して、以下の再確認のためのサンプル。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;遷移方法（Segue・Modal）の使用方針&lt;/li&gt;
&lt;li&gt;VC間のデータを受け渡す方法&lt;/li&gt;
&lt;li&gt;ライフサイクルの確認&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;Swift 3.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用方針&#34;&gt;使用方針&lt;/h2&gt;

&lt;h3 id=&#34;segue&#34;&gt;Segue&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Viewが提供する機能が完全に切り替わる場合に使用&lt;/li&gt;
&lt;li&gt;遷移のアクションを発火させるUIから、遷移先のViewControllerへ直接Segueを接続しない

&lt;ul&gt;
&lt;li&gt;遷移の発火がStoryBoardに埋もれるため&lt;/li&gt;
&lt;li&gt;Triggered Segues : manualを使用してVC間を接続&lt;/li&gt;
&lt;li&gt;発火させるUIからは、コードでSegueを実行する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;戻る処理はunwind Segueを使用&lt;/li&gt;
&lt;li&gt;データの受け渡し

&lt;ul&gt;
&lt;li&gt;各VCのprepare(for:sender:)にて、インスタンスを生成して行う&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプル

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mzgk/ManualSegue&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;modal&#34;&gt;Modal&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;元のViewから一時的に別機能を提供する場合に使用&lt;/li&gt;
&lt;li&gt;Segueを使用しないで、コードで表示させる

&lt;ul&gt;
&lt;li&gt;機能の切り替えではないため&lt;/li&gt;
&lt;li&gt;storyboard?.instantiateViewController(withIdentifier:) as! ModalのVCクラス名&lt;/li&gt;
&lt;li&gt;self.present(_:animated:completion:)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;閉じるのは表示元の責務とし、Modal側でDelegateプロトコルを定義する

&lt;ul&gt;
&lt;li&gt;表示元でDelegateプロトコルを実装し、Modalを閉じる&lt;/li&gt;
&lt;li&gt;self.dismiss(animated: true, completion: nil)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;データの受け渡し

&lt;ul&gt;
&lt;li&gt;元 → Modal : self.present(_:animated:completion:)前に生成したModalのインスタンスに設定&lt;/li&gt;
&lt;li&gt;Modal → 元 : Modal側でDelegateプロトコルを定義し、その引数を使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サンプル

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mzgk/ModalWithCode&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;
&lt;br&gt;
SegueとModalの使い分け方針とデータの受け渡し方法をすっきりさせるためのアウトプット。&lt;br /&gt;
ライフサイクルに関しては、シュミュレーターで実行したからなのかLayoutSubView()系が複数回コールされているのが、ちょっと違和感を感じる。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift3 ViewControllerのライフサイクル</title>
      <link>http://mzgkworks.com/post/swift3-viewcontroller-lifecycle/</link>
      <pubDate>Mon, 21 Nov 2016 17:42:49 +0900</pubDate>
      
      <guid>http://mzgkworks.com/post/swift3-viewcontroller-lifecycle/</guid>
      <description>

&lt;p&gt;ViewControllerのルートViewのライフサイクルを再確認。&lt;br /&gt;
各メソッドに以下のようなデバッグログを埋め込んで確認。&lt;br /&gt;
&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-@Swift&#34;&gt;override func loadView() {
    super.loadView()
    print(&amp;quot;VC1 :&amp;quot;, #function)
    // #functionで関数名が表示される
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 8.1&lt;/li&gt;
&lt;li&gt;Swift 3&lt;/li&gt;
&lt;li&gt;シュミュレーターで確認（iPhone6s 10.1）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;起動-ホームボタン-アプリアイコン&#34;&gt;起動 → ホームボタン → アプリアイコン&lt;/h2&gt;

&lt;h3 id=&#34;起動&#34;&gt;起動&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;application(_:didFinishLaunchingWithOptions:)&lt;/li&gt;
&lt;li&gt;VC1 : loadView()&lt;/li&gt;
&lt;li&gt;VC1 : viewDidLoad()&lt;/li&gt;
&lt;li&gt;VC1 : viewWillAppear&lt;/li&gt;
&lt;li&gt;applicationDidBecomeActive&lt;/li&gt;
&lt;li&gt;VC1 : viewWillLayoutSubviews()&lt;/li&gt;
&lt;li&gt;VC1 : viewDidLayoutSubviews()&lt;/li&gt;
&lt;li&gt;VC1 : viewWillLayoutSubviews()&lt;/li&gt;
&lt;li&gt;VC1 : viewDidLayoutSubviews()&lt;/li&gt;
&lt;li&gt;VC1 : viewDidAppear&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;ホームボタンをタップ&#34;&gt;ホームボタンをタップ&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;applicationWillResignActive&lt;/li&gt;
&lt;li&gt;applicationDidEnterBackground&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;アプリアイコンをタップ&#34;&gt;アプリアイコンをタップ&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;applicationWillEnterForeground&lt;/li&gt;
&lt;li&gt;applicationDidBecomeActive&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;vc1-ボタンタップ-vc2-モーダル表示&#34;&gt;VC1（ボタンタップ） → VC2（モーダル表示）&lt;/h2&gt;

&lt;h3 id=&#34;画面遷移&#34;&gt;画面遷移&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;VC1 : prepare(for:sender:)&lt;/li&gt;
&lt;li&gt;VC2 : loadView()&lt;/li&gt;
&lt;li&gt;VC2 : viewDidLoad()&lt;/li&gt;
&lt;li&gt;VC1 : viewWillDisappear&lt;/li&gt;
&lt;li&gt;VC2 : viewWillAppear&lt;/li&gt;
&lt;li&gt;VC2 : viewWillLayoutSubviews()&lt;/li&gt;
&lt;li&gt;VC2 : viewDidLayoutSubviews()&lt;/li&gt;
&lt;li&gt;VC1 : viewWillLayoutSubviews()  ← 謎&lt;/li&gt;
&lt;li&gt;VC1 : viewDidLayoutSubviews()   ← 謎&lt;/li&gt;
&lt;li&gt;VC2 : viewWillLayoutSubviews()  ← 謎&lt;/li&gt;
&lt;li&gt;VC2 : viewDidLayoutSubviews()   ← 謎&lt;/li&gt;
&lt;li&gt;VC2 : viewDidAppear&lt;/li&gt;
&lt;li&gt;VC1 : viewDidDisappear&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Swiftの引数についてのメモ</title>
      <link>http://mzgkworks.com/post/swift-argument/</link>
      <pubDate>Wed, 26 Oct 2016 16:27:37 +0900</pubDate>
      
      <guid>http://mzgkworks.com/post/swift-argument/</guid>
      <description>

&lt;p&gt;Swiftの引数について、1.x時代から変わったりうろ覚えだった部分もあったのでメモ。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Swift 3.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ラベル&#34;&gt;ラベル&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;argument label : 関数呼び出し用（呼び出し時に使用）

&lt;ul&gt;
&lt;li&gt;「_」をつけることで省略可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;parameter label : 関数定義用（関数内部で使用）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;argument-label-あり&#34;&gt;argument label : あり&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-@Swift&#34;&gt;// argument label : first, second
// parameter label : a, b
func addTwo(first a: Int, second b: Int)-&amp;gt; Int {
    return a + b
}

// 呼び出し
var value = addTwo(first: 1, second: 2)
// 結果 : 3
print(value)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;argument-label-なし&#34;&gt;argument label : なし&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-@Swift&#34;&gt;// parameter label : a, b
func addTwo(_ a: Int, _ b: Int)-&amp;gt; Int {
    return a + b
}

// 呼び出し
var value = addTwo(1, 2)
// 結果 : 3
print(value)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;デフォルト引数&#34;&gt;デフォルト引数&lt;/h2&gt;

&lt;p&gt;あたかじめ引数に値を設定しておくことで、呼び出し時に引数の省略が可能となる。&lt;br /&gt;
省略された場合、定義されているデフォルト値が適用される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-@Swift&#34;&gt;// aとbの文字列連結。セパレーターのcにデフォルト値（, ）を定義
func connectTwo(first a: String, second b: String, separator c: String = &amp;quot;, &amp;quot;)-&amp;gt; String {
    return a + c + b
}


// デフォルト引数を使う
var val = connectTwo(first: &amp;quot;A&amp;quot;, second: &amp;quot;B&amp;quot;)
// 結果 : A, B
print(val)


// デフォルト値を使わない
val = connectTwo(first: &amp;quot;A&amp;quot;, second: &amp;quot;B&amp;quot;, separator: &amp;quot;/ &amp;quot;)
// 結果 : A/ B
print(val)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;可変引数&#34;&gt;可変引数&lt;/h2&gt;

&lt;p&gt;あらかじめ引数の数がわからない場合などに使用する。&lt;br /&gt;
定義時は、型の後ろに「&amp;hellip;」をつける。&lt;br /&gt;
呼び出し時は、複数の値を「,（カンマ）」で区切って設定する。&lt;br /&gt;
可変引数の定義は、１関数につき１つまで。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-@Swift&#34;&gt;// 最初の引数が可変
// 引数の値をセパレーターで区切って連結する関数
func write(inWord a: String..., separator c: String = &amp;quot;, &amp;quot;)-&amp;gt; String {
    var output = &amp;quot;&amp;quot;
    for index in 0..&amp;lt;a.count {
        output += a[index] + c
    }
    return output
}

// １つの場合
var val = write(inWord: &amp;quot;ABC&amp;quot;)
// 結果 : ABC,
print(val)


// ３つの場合
val = write(inWord: &amp;quot;ABC&amp;quot;, &amp;quot;DEF&amp;quot;, &amp;quot;GHI&amp;quot;)
// 結果 : ABC, DEF, GHI,
print(val)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引数の値の変更&#34;&gt;引数の値の変更&lt;/h2&gt;

&lt;p&gt;引数の値は定数となるので、関数内での変更は不可。&lt;br /&gt;
ただし、インスタンスの場合は参照値が格納されているので、インスタンスの参照値は変更不可だが、中のプロパティ値の変更は可能。&lt;br /&gt;
※プロパティがvarで宣言されている場合のみ&lt;/p&gt;

&lt;h3 id=&#34;通常&#34;&gt;通常&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-@Swift&#34;&gt;// 引数aの値は変更できない
func change(_ a: String)-&amp;gt; String {
  a = &amp;quot;XYZ&amp;quot;   // ← Cannot assign to value &#39;a&#39; is a &#39;let&#39; constant
}

change(&amp;quot;ABC&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;インスタンスの場合&#34;&gt;インスタンスの場合&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-@Swift&#34;&gt;class Person {
    let name: String
    var age: Int    // ※ここがletの場合は、変更できない

    init(inName name:String, inAge age: Int) {
        self.name = name
        self.age = age
    }
}

// 引数で渡されたPerson型の引数のageプロパティを変更する関数
func update(inPerson person: Person) {
    person.age = 20
}

// Tomを10才で生成（Tom : 10）
var tom = Person(inName: &amp;quot;Tom&amp;quot;, inAge: 10)
print(&amp;quot;\(tom.name) : \(tom.age)&amp;quot;)


// 更新する関数に渡す
update(inPerson: tom)
// 結果 : Tom : 20
print(&amp;quot;\(tom.name) : \(tom.age)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;inoutparameter&#34;&gt;InOutParameter&lt;/h2&gt;

&lt;p&gt;定義時に型の前に「inout」をつけることで、引数の値を関数内で変更し呼び出し元に連携することができる。&lt;br /&gt;
呼び出し時は、引数の前に「&amp;amp;」をつける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-@Swift&#34;&gt;// 引数の値を入れ替える
func swap(first a: inout String, second b: inout String) {
    let tmp = a
    a = b
    b = tmp
}

var wordA = &amp;quot;ABC&amp;quot;
var wordZ = &amp;quot;XYZ&amp;quot;

// 入れ替え前 : wordA = ABC, wordZ = XYZ
print(&amp;quot;wordA = \(wordA), wordZ = \(wordZ)&amp;quot;)

// 入れ替え（引数に&amp;amp;がつく）
swap(first: &amp;amp;wordA, second: &amp;amp;wordZ)
// 入れ替え後 : wordA = XYZ, wordZ = ABC
print(&amp;quot;wordA = \(wordA), wordZ = \(wordZ)&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>